\documentclass[letterpaper,12pt]{article}
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{spverbatim}
\usepackage{bm}
\usepackage[colorlinks=true,citecolor=black,breaklinks=true,urlcolor=blue]{hyperref}
\usepackage{breakcites}
\usepackage[linesnumbered,vlined]{algorithm2e}
\usepackage[left=1.0in,right=1.0in,top=1.0in,bottom=1.0in]{geometry}  %Adjust page margins

%opening
\title{libcfd2lcs Manual}
% \author{Justin R. Finn}

\begin{document}
\maketitle
\section{Overview}
libcfd2lcs is a general purpose numerical library that performs the calculations needed to extract and visualize \emph{Lagrangian Coherent Structures} (LCS) from time dependent flows.  It is designed to work with two or three dimensional hydrodynamic datasets produced by computational fluid dynamics (CFD) simulations or experimental measurements.  It is capable of interfacing directly with a distributed memory CFD application, allowing for \emph{on-the-fly} calculation of LCS during numerical simulation.

The library is based on the method proposed by~\cite{finn2013integrated} for computing finite time Lyapunov exponent fields.  A detailed background on the methods used in the library can be found in this reference, as well as the papers by~\cite{brunton2010fast} and~\cite{leung2011eulerian}.  For an overview on theory and applications of LCS, we refer the reader to several excellent reviews on the subject~\cite{haller2015lagrangian,peacock2015introduction,peacock2010introduction,samelson2013lagrangian}.

Development of libcfd2lcs is funded by an eCSE grant from the \emph{Edinburgh Parallel Computing Center} (EPCC) and is a collaboration between the University of Liverpool, the University of Bristol, and the Stazione Zoologica Anton Dohrn, Naples.  We are continuing to develop new capabilites in the library and welcome collaboration from interested users.  New users can request a copy of the source code from \href{mailto:J.Finn@liverpool.ac.uk}{J.Finn@liverpool.ac.uk}.
 
\subsection*{Present Capabilities:}
 
\begin{itemize}
 \item Passive Lagrangian particle advection and visualization
 \item Computation of forward time and backward time FTLE fields
 \item User specified grid refinement.  
\end{itemize}

\section{Building the library}
\subsection*{Prerequisites}
\begin{itemize}
\item An MPI F90 and C compiler
\item LAPACK
\item HDF5 (optional, but recommended for large parallel runs).  HDF5 also requires libz, libm, and libdl to be installed on your system.
\end{itemize}

\subsection*{Compilation on supported platforms}
To build libcfd2lcs, the example programs, and the documentation on a currently supported platform, called \verb|$PLATFORM|, you can use the Makefile in the top-level \verb|/libcfd2lcs| directory:
\begin{itemize}
 \item \verb|make $PLATFORM|~~~~~~Builds libcfd2lcs. Supported values of \verb|$PLATFORM| are:
 \begin{enumerate}
  \item \verb|ARCHER|: EPSRC HPC (Cray XE-6)
  \item \verb|BLUECRYSTAL|:  University of Bristol HPC (IBM)
  \item \verb|AWESOMO4000|, \verb|AWESOMO4000-PROFILE|, \verb|LAPPY386|:  Linux workstations at the University of Liverpool
 \end{enumerate}
 \item \verb|make EXAMPLES|~~~~~~~Builds the example programs
 \item \verb|make DOC|~~~~~~~Builds this documentation.
 \item \verb|make distclean|~~~~~~~Cleans everything for a fresh install.
\end{itemize}

\subsection*{Compilation on new platforms}
The directory \verb|/libcfd2lcs/makefiles| contains several platform dependent Makefile.in scripts that define the libcfd2lcs build, including a blank version that can be edited for a new system called \verb|YOUR_NEW_PLATFORM|.  To compile on a new system: 
\begin{itemize}
 \item Edit the variables in the file \verb|/makefiles/Makefile.YOUR_NEW_PLATFORM.in| to match your system's configuration.
 \item \verb|make YOUR_NEW_PLATFORM|
 \item Email the file\\ \verb|/libcfd2lcs/makefiles/Makefile.YOUR_NEW_PLATFORM.in|, along with the name of your platform to \href{mailto:J.Finn@liverpool.ac.uk}{J.Finn@liverpool.ac.uk}.  Your build configuration will then be included in the next release of libcfd2lcs.
\end{itemize}
\subsection*{Compiling programs that link to libcfd2lcs}
The easiest way to understand how to compile an application that uses libcfd2lcs is to look at the programs provided in the \verb|/libcfd2lcs/examples| directory and the associated Makefile.  The following procedure is recommended:
\begin{itemize}
\item Add the following line to the top of your Makefile \\
\verb|include /path/to/your/libcfd2lcs/Makefile.in|\\
\item Add the include path \verb|$(CFD2LCS_INC)| when compiling object files. For example: \\
\verb|mpif90 -c -O3 $(CFD2LCS_INC) your_code.f90|
\item Add either \verb|$(CFD2LCS_SP_LIBS)| or \verb|$(CFD2LCS_DP_LIBS)| to your link line. Example:\\
\verb|mpif90 -o YOUR_APPLICATION your_code.o $(CFD2LCS_SP_LIBS)| (Single precision)\\
\verb|mpif90 -o YOUR_APPLICATION your_code.o $(CFD2LCS_DP_LIBS)| (Double precision)
\item Include one of the libcfd2lcs header files in the area of your source code that interfaces with libcfd2lcs:  This provides the required definitions to your application's code.\\
\begin{tabular}{lp{0.4\textwidth}}
\\
\hline \\
F90 Syntax for single precision: &\spverb|INCLUDE cfd2lcs_inc_sp.f90| \\
F90 Syntax for double precision: &\spverb|INCLUDE cfd2lcs_inc_dp.f90| \\
C Syntax for single precision:&\spverb|#include "cfd2lcs_inc_sp.h"|\\
C Syntax for double precision:&\spverb|#include "cfd2lcs_inc_dp.h"|\\
\\
\hline
\end{tabular}
\end{itemize}

\section{Usage}
The library allows the user to compute LCS from velocity data they have produced in their application.  Below, we summarize the typical usage pattern:
\begin{algorithm}
\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
% \KwIn{A finite set $A=\{a_1, a_2, \ldots, a_n\}$ of integers}
% \KwOut{The largest element in the set}
{\bf Start Of User's Application}\\
Establish user's grid coordinates \\
Establish user's boundary conditions\\
Establish user's domain decomposition\\
\verb|call cfd2lcs_init|\\
\verb|call cfd2lcs_diagnostic_init| \\
\verb|call cfd2lcs_set_option| \\ 
$t=t_{start}$;\\
\While{$t < t_{finish}$} {
Establish new velocity field at time $t$\\
\texttt{call cfd2lcs\_update}\\
$t = t+dt$\\
}
{\bf End Of User's Application}\\
%  \caption{Typical user pattern for cfd2lcs}
\label{algo:max}
\end{algorithm}

The calls made to libcfd2lcs are:
\begin{itemize}
 \item \verb|cfd2lcs_init|:  This should be the first call to the libcfd2lcs library.  It initializes the communications and data storage required for the user's application.
 \item \verb|cfd2lcs_init_diagnostic|:  Initializes an LCS diagnostic to compute
 \item \verb|cfd2lcs_set_option|: Sets a user accessible option
 \item \verb|cfd2lcs_update|:  Updates all LCS diagnostics using the latest velocity field.
\end{itemize}
\clearpage
\subsection{libcfd2lcs Function Definitions}
All libcfd2lcs capability can be accessed by the user from either Fortran or C/C++.
\subsubsection*{Library initialization: cfd2lcs\_init / cfd2lcs\_init\_c}
\begin{tabular}{lp{0.7\textwidth}}
\hline 
\bf{F90 Syntax}:&\spverb|call cfd2lcs_init(comm,n,offset,x,y,z,bcflag)| \\
\verb|MPI_comm| & \verb|comm|\\
\verb|integer| & \verb|n|\\
\verb|integer| & \verb|offset|\\
\verb|real(LCSRP)| & \verb|x|\\
\verb|real(LCSRP)| & \verb|y|\\
\verb|real(LCSRP)| & \verb|z|\\
\verb|integer| & \verb|bcflag|\\
\hline
\bf{C/C++ Syntax:}&\spverb|cfd2lcs_init_c(comm,n,offset,x,y,z,bcflag);|\\
\verb|MPI_comm| & \verb|comm;|\\
\verb|int| & \verb|n;|\\
\verb|int| & \verb|offset;|\\
\verb|lcsdata_t| & \verb|*x;|\\
\verb|lcsdata_t| & \verb|*y;|\\
\verb|lcsdata_t| & \verb|*z;|\\
\verb|int| & \verb|*bcflag;|\\
\hline \\
\verb|comm| & MPI communicator used by the applications for global communications.\\
\verb|n| & Vector of 3 integers defining the local number of grid points for each processor in the first, second and third dimensions.\\
\verb|offset| & Vector of 3 integers defining each processor's offset in the the globally structured array.  For example, if \verb|n = [16,16,32]|, and \verb|offset =[0,16,8]| then this process owns data with indices \verb|[1-16,17-32,9-48]| in the global array space (indices starting at 1).\\
\verb|x|& Array of size \verb|n[1]|$\times$\verb|n[2]|$\times$\verb|n[3]| of X grid coordinates.\\
\verb|y|& Array of size \verb|n[1]|$\times$\verb|n[2]|$\times$\verb|n[3]| of Y grid coordinates.\\
\verb|z|& Array of size \verb|n[1]|$\times$\verb|n[2]|$\times$\verb|n[3]| of Z grid coordinates.\\
\verb|bcflag|& Array of size \verb|n[1]|$\times$\verb|n[2]|$\times$\verb|n[3]| containing a flag indicating the boundary condition at each grid point.  Acceptable values for \verb|bcflag| are given in the next section.\\
% &\begin{itemize}
%   \item \verb|LCS_INTERNAL|
%   \item \verb|LCS_WALL|
%   \item \verb|LCS_SLIP|
%   \item \verb|LCS_OUTFLOW|
%   \item \verb|LCS_INFLOW|
%   \item \verb|LCS_INTERNAL|
%  \end{itemize}
\end{tabular}

% 
% \subsection*{LCS diagnostic initialization: cfd2lcs\_diagnostic\_init \& cfd2lcs\_diagnostic\_init\_c}
% This is used to initialize an LCS diagnostic\\
% \begin{tabular}{lp{0.8\textwidth}}
% \hline \\
% 
% F90 Syntax:&\spverb|cfd2lcs_diagnostic_init(lcs_handle,LCS_TYPE, resolution, T, h, rhop, dp, label)| \\
% C Syntax:&\spverb|void cfd2lcs_diagnostic_init_c(int LCS_TYPE, int resolution, lcsdata_t T, lcsdata_t h, lcsdata_t rhop, lcsdata_t  dp, char label);|\\
% \hline \\
% \verb|lcs_handle| & An integer handle that the user can keep track of for each LCS they initialize\\
% \verb|LCS_TYPE| & A flag identifying the type of LCS. Current options are \verb|FTLE_FWD|, \verb|FTLE_BKWD|, \verb|LP_TRACER|\\
% \verb|resolution| & An integer that lets the user add or remove grid points for the LCS calculation, relative to the grid which simulation side data is stored on.  0 = use the same grid, positive integers add grid points, negative integers subtract grid points.\\
% \verb|T| & The LCS integration time\\
% \verb|h| & The LCS visualization (output) interval\\
% \verb|rhop| & The LCS particle density\\
% \verb|dp| &  The LCS particle size\\
% \verb|label| & Character string used as identifier for the LCS\\
% 
% 
% \end{tabular}
% 
% \subsection*{LCS update:\\ cfd2lcs\_update \& cfd2lcs\_update\_c}
% This is used to update the LCS diagnostics after a new velocity field is obtained\\
% \begin{tabular}{lp{0.8\textwidth}}
% \hline \\
% F90 Syntax:&\spverb|cfd2lcs_update(n, u, v, w, time)| \\
% C Syntax:&\spverb|void cfd2lcs_update_c(int n[3], lcsdata_t *u, lcsdata_t *v, lcsdata_t *w, lcsdata_t time, int datalayout);|\\
% \hline \\
% \verb|n| & Vector of 3 integers that define the local number of grid points for each
% processor (this can vary from processor-to-processor)\\
% \verb|u| & Array of size \verb|n[1]*n[2]*n[3]| containing the X component of velocity\\
% \verb|v| & Array of size \verb|n[1]*n[2]*n[3]| containing the Y component of velocity\\
% \verb|w| & Array of size \verb|n[1]*n[2]*n[3]| containing the Z component of velocity\\
% \verb|time| & The current simulation time\\
% \verb|datalayout| & An integer flag that tells libcfd2lcs how the data in x y and z vectors are arranged (for example 3 independent vectors, 1 interlaced vector, etc...).  For now, only one option, \verb|LCS_3V|, and this is only passed to the C interface, but we can add new formats to suit different codes in the near future.   
% \end{tabular}
% 


%Bibliography:
\bibliographystyle{apalike}
\bibliography{libcfd2lcs}


\end{document}
